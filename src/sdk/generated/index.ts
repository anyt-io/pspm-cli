/**
 * Generated by orval v8.0.2 ðŸº
 * Do not edit manually.
 * PSPM API
 * Backend API for PSPM - Private Skill Package Manager for Claude Code
 * OpenAPI spec version: 1.0.0
 */
import { customFetch } from "../fetcher";
/**
 * API key record (without the key value)
 */
export interface ApiKey {
	id: string;
	name: string;
	keyPrefix: string;
	userId: string;
	expiresAt: string | null;
	lastUsedAt: string | null;
	createdAt: string | null;
}

export type ApiKeyListResponse = ApiKey[];

export type Item = {
	path: (string | number)[];
	message: string;
};

export type ApiErrorCode = (typeof ApiErrorCode)[keyof typeof ApiErrorCode];

export const ApiErrorCode = {
	BAD_REQUEST: "BAD_REQUEST",
	UNAUTHORIZED: "UNAUTHORIZED",
	FORBIDDEN: "FORBIDDEN",
	NOT_FOUND: "NOT_FOUND",
	CONFLICT: "CONFLICT",
	VALIDATION_ERROR: "VALIDATION_ERROR",
	INTERNAL_ERROR: "INTERNAL_ERROR",
} as const;

export type ApiErrorDetails = { [key: string]: unknown | null };

export interface ApiError {
	code: ApiErrorCode;
	message: string;
	details?: ApiErrorDetails;
	requestId?: string;
	timestamp: string;
}

export type ValidationError = ApiError & {
	code?: "VALIDATION_ERROR";
	details: {
		issues: Item[];
	};
};

/**
 * Created API key with the plain key (only shown once)
 */
export interface CreateApiKeyResponse {
	apiKey: ApiKey;
	plainKey: string;
}

/**
 * Input for creating a new API key
 */
export interface CreateApiKeyInput {
	/**
	 * @minLength 1
	 * @maxLength 100
	 */
	name: string;
	expiresAt?: string | null;
}

export interface SuccessResponse {
	success: boolean;
}

export interface DeleteApiKeyInput {
	id: string;
}

export interface UpdateApiKeyInput {
	id: string;
	/**
	 * @minLength 1
	 * @maxLength 100
	 */
	name: string;
}

export interface CreateCliTokenResponse {
	token: string;
}

export interface CreateCliTokenInput {
	/** @minLength 1 */
	state: string;
	/** @minLength 1 */
	port: string;
}

export interface ExchangeCliTokenResponse {
	apiKey: string;
	username: string;
}

export interface ExchangeCliTokenInput {
	/** @minLength 1 */
	token: string;
}

/**
 * User's username information. Username is immutable once set.
 */
export interface UsernameInfo {
	username: string | null;
	isSet: boolean;
}

export interface CheckUsernameOutput {
	available: boolean;
	error: string | null;
}

export interface UpdateUsernameOutput {
	success: boolean;
	username: string | null;
	error: string | null;
}

export interface UpdateUsernameInput {
	/**
	 * @minLength 3
	 * @maxLength 39
	 */
	username: string;
}

export interface GetSuggestionsOutput {
	suggestions: string[];
}

/**
 * Current user info
 */
export type MeResponseData = {
	userId: string;
	username: string;
} | null;

/**
 * Package visibility (private or public)
 */
export type Visibility = (typeof Visibility)[keyof typeof Visibility];

export const Visibility = {
	private: "private",
	public: "public",
} as const;

/**
 * Skill metadata
 */
export interface Skill {
	id: string;
	name: string;
	userId: string;
	description: string | null;
	createdAt: string | null;
	updatedAt: string | null;
	visibility: Visibility;
}

/**
 * Skill metadata with owner username
 */
export type SkillWithUser = Skill & {
	username: string;
};

/**
 * List of skills
 */
export type SkillListResponse = SkillWithUser[];

/**
 * User's username
 * @minLength 1
 * @maxLength 50
 * @pattern ^[a-zA-Z0-9_-]+$
 */
export type Username = string;

/**
 * Skill name identifier
 * @minLength 1
 * @maxLength 100
 * @pattern ^[a-z][a-z0-9-]*$
 */
export type SkillName = string;

/**
 * Semantic version string (e.g., 1.0.0)
 */
export type Semver = string;

export type PspmMetadataType =
	(typeof PspmMetadataType)[keyof typeof PspmMetadataType];

export const PspmMetadataType = {
	skill: "skill",
} as const;

export type PspmMetadataRequirements = {
	claude?: string;
	node?: string;
};

/**
 * PSPM-specific metadata for the skill package
 */
export interface PspmMetadata {
	type: PspmMetadataType;
	capabilities?: string[];
	requirements?: PspmMetadataRequirements;
}

/**
 * Skill package manifest (package.json)
 */
export interface SkillManifest {
	name: SkillName;
	version: Semver;
	/** @maxLength 500 */
	description?: string;
	files?: string[];
	pspm?: PspmMetadata;
}

/**
 * Skill version metadata
 */
export interface SkillVersion {
	id: string;
	skillId: string;
	version: string;
	r2Key: string;
	checksum: string;
	manifest: SkillManifest;
	publishedAt: string | null;
	deprecatedAt?: string | null;
	deprecationMessage?: string | null;
}

/**
 * Skill version metadata with download URL
 */
export type SkillVersionWithDownload =
	| (SkillVersion & {
			downloadUrl: string;
	  })
	| null;

/**
 * Published skill with version info
 */
export interface PublishSkillResponse {
	skill: SkillWithUser;
	version: SkillVersion;
}

/**
 * Input for publishing a skill
 */
export interface PublishSkillInput {
	manifest: SkillManifest;
	/** @maxLength 73400320 */
	tarballBase64: string;
}

/**
 * Input for deprecating a skill version
 */
export interface DeprecateVersionInput {
	/**
	 * @minLength 1
	 * @maxLength 500
	 */
	message: string;
}

/**
 * Updated skill after changing visibility
 */
export type ChangeAccessResponse = Skill & {
	username: string;
};

/**
 * Input for changing package visibility
 */
export interface ChangeAccessInput {
	visibility: Visibility;
}

export type CapturedErrorSource =
	(typeof CapturedErrorSource)[keyof typeof CapturedErrorSource];

export const CapturedErrorSource = {
	hydration: "hydration",
	loader: "loader",
	action: "action",
	render: "render",
	streaming: "streaming",
	network: "network",
	global: "global",
	unknown: "unknown",
} as const;

export type CapturedErrorSeverity =
	(typeof CapturedErrorSeverity)[keyof typeof CapturedErrorSeverity];

export const CapturedErrorSeverity = {
	fatal: "fatal",
	error: "error",
	warning: "warning",
	info: "info",
} as const;

export type CapturedErrorContext = { [key: string]: unknown | null };

/**
 * A captured client error
 */
export interface CapturedError {
	id: string;
	message: string;
	stack?: string;
	componentStack?: string;
	source: CapturedErrorSource;
	severity: CapturedErrorSeverity;
	route?: string;
	timestamp: number;
	context?: CapturedErrorContext;
	digest?: string;
}

/**
 * Payload for reporting client errors
 */
export interface ErrorReportPayload {
	errors: CapturedError[];
	userAgent: string;
	url: string;
	timestamp: number;
}

export type CheckUsernameAvailabilityParams = {
	/**
	 * @minLength 3
	 * @maxLength 39
	 */
	username: string;
};

/**
 * Retrieve all API keys for the authenticated user
 * @summary List all API keys
 */
export type listApiKeysResponse200 = {
	data: ApiKeyListResponse;
	status: 200;
};

export type listApiKeysResponse400 = {
	data: ValidationError;
	status: 400;
};

export type listApiKeysResponse401 = {
	data: ApiError;
	status: 401;
};

export type listApiKeysResponse403 = {
	data: ApiError;
	status: 403;
};

export type listApiKeysResponse404 = {
	data: ApiError;
	status: 404;
};

export type listApiKeysResponse500 = {
	data: ApiError;
	status: 500;
};

export type listApiKeysResponseSuccess = listApiKeysResponse200 & {
	headers: Headers;
};
export type listApiKeysResponseError = (
	| listApiKeysResponse400
	| listApiKeysResponse401
	| listApiKeysResponse403
	| listApiKeysResponse404
	| listApiKeysResponse500
) & {
	headers: Headers;
};

export type listApiKeysResponse =
	| listApiKeysResponseSuccess
	| listApiKeysResponseError;

export const getListApiKeysUrl = () => {
	return "/api/api-keys/api-keys";
};

export const listApiKeys = async (
	options?: RequestInit,
): Promise<listApiKeysResponse> => {
	return customFetch<listApiKeysResponse>(getListApiKeysUrl(), {
		...options,
		method: "GET",
	});
};

/**
 * Create a new API key with optional expiration
 * @summary Create a new API key
 */
export type createApiKeyResponse200 = {
	data: CreateApiKeyResponse;
	status: 200;
};

export type createApiKeyResponse400 = {
	data: ValidationError;
	status: 400;
};

export type createApiKeyResponse401 = {
	data: ApiError;
	status: 401;
};

export type createApiKeyResponse403 = {
	data: ApiError;
	status: 403;
};

export type createApiKeyResponse404 = {
	data: ApiError;
	status: 404;
};

export type createApiKeyResponse500 = {
	data: ApiError;
	status: 500;
};

export type createApiKeyResponseSuccess = createApiKeyResponse200 & {
	headers: Headers;
};
export type createApiKeyResponseError = (
	| createApiKeyResponse400
	| createApiKeyResponse401
	| createApiKeyResponse403
	| createApiKeyResponse404
	| createApiKeyResponse500
) & {
	headers: Headers;
};

export type createApiKeyResponse =
	| createApiKeyResponseSuccess
	| createApiKeyResponseError;

export const getCreateApiKeyUrl = () => {
	return "/api/api-keys/api-keys";
};

export const createApiKey = async (
	createApiKeyInput: CreateApiKeyInput,
	options?: RequestInit,
): Promise<createApiKeyResponse> => {
	return customFetch<createApiKeyResponse>(getCreateApiKeyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createApiKeyInput),
	});
};

/**
 * Revoke and delete an API key
 * @summary Delete an API key
 */
export type deleteApiKeyResponse200 = {
	data: SuccessResponse;
	status: 200;
};

export type deleteApiKeyResponse400 = {
	data: ValidationError;
	status: 400;
};

export type deleteApiKeyResponse401 = {
	data: ApiError;
	status: 401;
};

export type deleteApiKeyResponse403 = {
	data: ApiError;
	status: 403;
};

export type deleteApiKeyResponse404 = {
	data: ApiError;
	status: 404;
};

export type deleteApiKeyResponse500 = {
	data: ApiError;
	status: 500;
};

export type deleteApiKeyResponseSuccess = deleteApiKeyResponse200 & {
	headers: Headers;
};
export type deleteApiKeyResponseError = (
	| deleteApiKeyResponse400
	| deleteApiKeyResponse401
	| deleteApiKeyResponse403
	| deleteApiKeyResponse404
	| deleteApiKeyResponse500
) & {
	headers: Headers;
};

export type deleteApiKeyResponse =
	| deleteApiKeyResponseSuccess
	| deleteApiKeyResponseError;

export const getDeleteApiKeyUrl = () => {
	return "/api/api-keys/api-keys";
};

export const deleteApiKey = async (
	deleteApiKeyInput: DeleteApiKeyInput,
	options?: RequestInit,
): Promise<deleteApiKeyResponse> => {
	return customFetch<deleteApiKeyResponse>(getDeleteApiKeyUrl(), {
		...options,
		method: "DELETE",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(deleteApiKeyInput),
	});
};

/**
 * Update the name/description of an API key
 * @summary Update API key name
 */
export type updateApiKeyNameResponse200 = {
	data: ApiKey;
	status: 200;
};

export type updateApiKeyNameResponse400 = {
	data: ValidationError;
	status: 400;
};

export type updateApiKeyNameResponse401 = {
	data: ApiError;
	status: 401;
};

export type updateApiKeyNameResponse403 = {
	data: ApiError;
	status: 403;
};

export type updateApiKeyNameResponse404 = {
	data: ApiError;
	status: 404;
};

export type updateApiKeyNameResponse500 = {
	data: ApiError;
	status: 500;
};

export type updateApiKeyNameResponseSuccess = updateApiKeyNameResponse200 & {
	headers: Headers;
};
export type updateApiKeyNameResponseError = (
	| updateApiKeyNameResponse400
	| updateApiKeyNameResponse401
	| updateApiKeyNameResponse403
	| updateApiKeyNameResponse404
	| updateApiKeyNameResponse500
) & {
	headers: Headers;
};

export type updateApiKeyNameResponse =
	| updateApiKeyNameResponseSuccess
	| updateApiKeyNameResponseError;

export const getUpdateApiKeyNameUrl = () => {
	return "/api/api-keys/api-keys";
};

export const updateApiKeyName = async (
	updateApiKeyInput: UpdateApiKeyInput,
	options?: RequestInit,
): Promise<updateApiKeyNameResponse> => {
	return customFetch<updateApiKeyNameResponse>(getUpdateApiKeyNameUrl(), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateApiKeyInput),
	});
};

/**
 * Create a short-lived token for CLI browser-based authentication
 * @summary Create a CLI login token
 */
export type createCliTokenResponse200 = {
	data: CreateCliTokenResponse;
	status: 200;
};

export type createCliTokenResponse400 = {
	data: ValidationError;
	status: 400;
};

export type createCliTokenResponse401 = {
	data: ApiError;
	status: 401;
};

export type createCliTokenResponse403 = {
	data: ApiError;
	status: 403;
};

export type createCliTokenResponse404 = {
	data: ApiError;
	status: 404;
};

export type createCliTokenResponse500 = {
	data: ApiError;
	status: 500;
};

export type createCliTokenResponseSuccess = createCliTokenResponse200 & {
	headers: Headers;
};
export type createCliTokenResponseError = (
	| createCliTokenResponse400
	| createCliTokenResponse401
	| createCliTokenResponse403
	| createCliTokenResponse404
	| createCliTokenResponse500
) & {
	headers: Headers;
};

export type createCliTokenResponse =
	| createCliTokenResponseSuccess
	| createCliTokenResponseError;

export const getCreateCliTokenUrl = () => {
	return "/api/api-keys/cli-token";
};

export const createCliToken = async (
	createCliTokenInput: CreateCliTokenInput,
	options?: RequestInit,
): Promise<createCliTokenResponse> => {
	return customFetch<createCliTokenResponse>(getCreateCliTokenUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createCliTokenInput),
	});
};

/**
 * Exchange a CLI login token for an API key (called by CLI after browser redirect)
 * @summary Exchange CLI token for API key
 */
export type exchangeCliTokenResponse200 = {
	data: ExchangeCliTokenResponse;
	status: 200;
};

export type exchangeCliTokenResponse400 = {
	data: ValidationError;
	status: 400;
};

export type exchangeCliTokenResponse401 = {
	data: ApiError;
	status: 401;
};

export type exchangeCliTokenResponse403 = {
	data: ApiError;
	status: 403;
};

export type exchangeCliTokenResponse404 = {
	data: ApiError;
	status: 404;
};

export type exchangeCliTokenResponse500 = {
	data: ApiError;
	status: 500;
};

export type exchangeCliTokenResponseSuccess = exchangeCliTokenResponse200 & {
	headers: Headers;
};
export type exchangeCliTokenResponseError = (
	| exchangeCliTokenResponse400
	| exchangeCliTokenResponse401
	| exchangeCliTokenResponse403
	| exchangeCliTokenResponse404
	| exchangeCliTokenResponse500
) & {
	headers: Headers;
};

export type exchangeCliTokenResponse =
	| exchangeCliTokenResponseSuccess
	| exchangeCliTokenResponseError;

export const getExchangeCliTokenUrl = () => {
	return "/api/api-keys/cli-token-exchange";
};

export const exchangeCliToken = async (
	exchangeCliTokenInput: ExchangeCliTokenInput,
	options?: RequestInit,
): Promise<exchangeCliTokenResponse> => {
	return customFetch<exchangeCliTokenResponse>(getExchangeCliTokenUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(exchangeCliTokenInput),
	});
};

/**
 * Get current user's username and whether it has been set
 * @summary Get username info
 */
export type getUsernameInfoResponse200 = {
	data: UsernameInfo;
	status: 200;
};

export type getUsernameInfoResponse400 = {
	data: ValidationError;
	status: 400;
};

export type getUsernameInfoResponse401 = {
	data: ApiError;
	status: 401;
};

export type getUsernameInfoResponse403 = {
	data: ApiError;
	status: 403;
};

export type getUsernameInfoResponse404 = {
	data: ApiError;
	status: 404;
};

export type getUsernameInfoResponse500 = {
	data: ApiError;
	status: 500;
};

export type getUsernameInfoResponseSuccess = getUsernameInfoResponse200 & {
	headers: Headers;
};
export type getUsernameInfoResponseError = (
	| getUsernameInfoResponse400
	| getUsernameInfoResponse401
	| getUsernameInfoResponse403
	| getUsernameInfoResponse404
	| getUsernameInfoResponse500
) & {
	headers: Headers;
};

export type getUsernameInfoResponse =
	| getUsernameInfoResponseSuccess
	| getUsernameInfoResponseError;

export const getGetUsernameInfoUrl = () => {
	return "/api/auth/username";
};

export const getUsernameInfo = async (
	options?: RequestInit,
): Promise<getUsernameInfoResponse> => {
	return customFetch<getUsernameInfoResponse>(getGetUsernameInfoUrl(), {
		...options,
		method: "GET",
	});
};

/**
 * Set the current user's username. This is a one-time operation - username cannot be changed after being set (npm-style).
 * @summary Set username (one-time)
 */
export type setUsernameResponse200 = {
	data: UpdateUsernameOutput;
	status: 200;
};

export type setUsernameResponse400 = {
	data: ValidationError;
	status: 400;
};

export type setUsernameResponse401 = {
	data: ApiError;
	status: 401;
};

export type setUsernameResponse403 = {
	data: ApiError;
	status: 403;
};

export type setUsernameResponse404 = {
	data: ApiError;
	status: 404;
};

export type setUsernameResponse500 = {
	data: ApiError;
	status: 500;
};

export type setUsernameResponseSuccess = setUsernameResponse200 & {
	headers: Headers;
};
export type setUsernameResponseError = (
	| setUsernameResponse400
	| setUsernameResponse401
	| setUsernameResponse403
	| setUsernameResponse404
	| setUsernameResponse500
) & {
	headers: Headers;
};

export type setUsernameResponse =
	| setUsernameResponseSuccess
	| setUsernameResponseError;

export const getSetUsernameUrl = () => {
	return "/api/auth/username";
};

export const setUsername = async (
	updateUsernameInput: UpdateUsernameInput,
	options?: RequestInit,
): Promise<setUsernameResponse> => {
	return customFetch<setUsernameResponse>(getSetUsernameUrl(), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateUsernameInput),
	});
};

/**
 * Check if a username is available for use. This endpoint is public and can be called during signup.
 * @summary Check username availability
 */
export type checkUsernameAvailabilityResponse200 = {
	data: CheckUsernameOutput;
	status: 200;
};

export type checkUsernameAvailabilityResponse400 = {
	data: ValidationError;
	status: 400;
};

export type checkUsernameAvailabilityResponse401 = {
	data: ApiError;
	status: 401;
};

export type checkUsernameAvailabilityResponse403 = {
	data: ApiError;
	status: 403;
};

export type checkUsernameAvailabilityResponse404 = {
	data: ApiError;
	status: 404;
};

export type checkUsernameAvailabilityResponse500 = {
	data: ApiError;
	status: 500;
};

export type checkUsernameAvailabilityResponseSuccess =
	checkUsernameAvailabilityResponse200 & {
		headers: Headers;
	};
export type checkUsernameAvailabilityResponseError = (
	| checkUsernameAvailabilityResponse400
	| checkUsernameAvailabilityResponse401
	| checkUsernameAvailabilityResponse403
	| checkUsernameAvailabilityResponse404
	| checkUsernameAvailabilityResponse500
) & {
	headers: Headers;
};

export type checkUsernameAvailabilityResponse =
	| checkUsernameAvailabilityResponseSuccess
	| checkUsernameAvailabilityResponseError;

export const getCheckUsernameAvailabilityUrl = (
	params: CheckUsernameAvailabilityParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/api/auth/username/check?${stringifiedParams}`
		: "/api/auth/username/check";
};

export const checkUsernameAvailability = async (
	params: CheckUsernameAvailabilityParams,
	options?: RequestInit,
): Promise<checkUsernameAvailabilityResponse> => {
	return customFetch<checkUsernameAvailabilityResponse>(
		getCheckUsernameAvailabilityUrl(params),
		{
			...options,
			method: "GET",
		},
	);
};

/**
 * Get available username suggestions based on user's email and name
 * @summary Get username suggestions
 */
export type getUsernameSuggestionsResponse200 = {
	data: GetSuggestionsOutput;
	status: 200;
};

export type getUsernameSuggestionsResponse400 = {
	data: ValidationError;
	status: 400;
};

export type getUsernameSuggestionsResponse401 = {
	data: ApiError;
	status: 401;
};

export type getUsernameSuggestionsResponse403 = {
	data: ApiError;
	status: 403;
};

export type getUsernameSuggestionsResponse404 = {
	data: ApiError;
	status: 404;
};

export type getUsernameSuggestionsResponse500 = {
	data: ApiError;
	status: 500;
};

export type getUsernameSuggestionsResponseSuccess =
	getUsernameSuggestionsResponse200 & {
		headers: Headers;
	};
export type getUsernameSuggestionsResponseError = (
	| getUsernameSuggestionsResponse400
	| getUsernameSuggestionsResponse401
	| getUsernameSuggestionsResponse403
	| getUsernameSuggestionsResponse404
	| getUsernameSuggestionsResponse500
) & {
	headers: Headers;
};

export type getUsernameSuggestionsResponse =
	| getUsernameSuggestionsResponseSuccess
	| getUsernameSuggestionsResponseError;

export const getGetUsernameSuggestionsUrl = () => {
	return "/api/auth/username/suggestions";
};

export const getUsernameSuggestions = async (
	options?: RequestInit,
): Promise<getUsernameSuggestionsResponse> => {
	return customFetch<getUsernameSuggestionsResponse>(
		getGetUsernameSuggestionsUrl(),
		{
			...options,
			method: "GET",
		},
	);
};

/**
 * Get the current authenticated user's info
 * @summary Get current user
 */
export type meResponse200 = {
	data: MeResponseData | null;
	status: 200;
};

export type meResponse400 = {
	data: ValidationError;
	status: 400;
};

export type meResponse401 = {
	data: ApiError;
	status: 401;
};

export type meResponse403 = {
	data: ApiError;
	status: 403;
};

export type meResponse404 = {
	data: ApiError;
	status: 404;
};

export type meResponse500 = {
	data: ApiError;
	status: 500;
};

export type meResponseSuccess = meResponse200 & {
	headers: Headers;
};
export type meResponseError = (
	| meResponse400
	| meResponse401
	| meResponse403
	| meResponse404
	| meResponse500
) & {
	headers: Headers;
};

export type meResponse = meResponseSuccess | meResponseError;

export const getMeUrl = () => {
	return "/api/skills/me";
};

export const me = async (options?: RequestInit): Promise<meResponse> => {
	return customFetch<meResponse>(getMeUrl(), {
		...options,
		method: "GET",
	});
};

/**
 * List all skills owned by the authenticated user
 * @summary List my skills
 */
export type listMySkillsResponse200 = {
	data: SkillListResponse;
	status: 200;
};

export type listMySkillsResponse400 = {
	data: ValidationError;
	status: 400;
};

export type listMySkillsResponse401 = {
	data: ApiError;
	status: 401;
};

export type listMySkillsResponse403 = {
	data: ApiError;
	status: 403;
};

export type listMySkillsResponse404 = {
	data: ApiError;
	status: 404;
};

export type listMySkillsResponse500 = {
	data: ApiError;
	status: 500;
};

export type listMySkillsResponseSuccess = listMySkillsResponse200 & {
	headers: Headers;
};
export type listMySkillsResponseError = (
	| listMySkillsResponse400
	| listMySkillsResponse401
	| listMySkillsResponse403
	| listMySkillsResponse404
	| listMySkillsResponse500
) & {
	headers: Headers;
};

export type listMySkillsResponse =
	| listMySkillsResponseSuccess
	| listMySkillsResponseError;

export const getListMySkillsUrl = () => {
	return "/api/skills";
};

export const listMySkills = async (
	options?: RequestInit,
): Promise<listMySkillsResponse> => {
	return customFetch<listMySkillsResponse>(getListMySkillsUrl(), {
		...options,
		method: "GET",
	});
};

/**
 * List all skills for a specific user
 * @summary List user skills
 */
export type listUserSkillsResponse200 = {
	data: SkillListResponse;
	status: 200;
};

export type listUserSkillsResponse400 = {
	data: ValidationError;
	status: 400;
};

export type listUserSkillsResponse401 = {
	data: ApiError;
	status: 401;
};

export type listUserSkillsResponse403 = {
	data: ApiError;
	status: 403;
};

export type listUserSkillsResponse404 = {
	data: ApiError;
	status: 404;
};

export type listUserSkillsResponse500 = {
	data: ApiError;
	status: 500;
};

export type listUserSkillsResponseSuccess = listUserSkillsResponse200 & {
	headers: Headers;
};
export type listUserSkillsResponseError = (
	| listUserSkillsResponse400
	| listUserSkillsResponse401
	| listUserSkillsResponse403
	| listUserSkillsResponse404
	| listUserSkillsResponse500
) & {
	headers: Headers;
};

export type listUserSkillsResponse =
	| listUserSkillsResponseSuccess
	| listUserSkillsResponseError;

export const getListUserSkillsUrl = (username: Username) => {
	return `/api/skills/@user/${username}`;
};

export const listUserSkills = async (
	username: Username,
	options?: RequestInit,
): Promise<listUserSkillsResponse> => {
	return customFetch<listUserSkillsResponse>(getListUserSkillsUrl(username), {
		...options,
		method: "GET",
	});
};

/**
 * Get a specific skill by username and name
 * @summary Get skill
 */
export type getSkillResponse200 = {
	data: SkillWithUser;
	status: 200;
};

export type getSkillResponse400 = {
	data: ValidationError;
	status: 400;
};

export type getSkillResponse401 = {
	data: ApiError;
	status: 401;
};

export type getSkillResponse403 = {
	data: ApiError;
	status: 403;
};

export type getSkillResponse404 = {
	data: ApiError;
	status: 404;
};

export type getSkillResponse500 = {
	data: ApiError;
	status: 500;
};

export type getSkillResponseSuccess = getSkillResponse200 & {
	headers: Headers;
};
export type getSkillResponseError = (
	| getSkillResponse400
	| getSkillResponse401
	| getSkillResponse403
	| getSkillResponse404
	| getSkillResponse500
) & {
	headers: Headers;
};

export type getSkillResponse = getSkillResponseSuccess | getSkillResponseError;

export const getGetSkillUrl = (username: Username, name: SkillName) => {
	return `/api/skills/@user/${username}/${name}`;
};

export const getSkill = async (
	username: Username,
	name: SkillName,
	options?: RequestInit,
): Promise<getSkillResponse> => {
	return customFetch<getSkillResponse>(getGetSkillUrl(username, name), {
		...options,
		method: "GET",
	});
};

/**
 * List all versions for a specific skill
 * @summary List skill versions
 */
export type listSkillVersionsResponse200 = {
	data: SkillVersion[];
	status: 200;
};

export type listSkillVersionsResponse400 = {
	data: ValidationError;
	status: 400;
};

export type listSkillVersionsResponse401 = {
	data: ApiError;
	status: 401;
};

export type listSkillVersionsResponse403 = {
	data: ApiError;
	status: 403;
};

export type listSkillVersionsResponse404 = {
	data: ApiError;
	status: 404;
};

export type listSkillVersionsResponse500 = {
	data: ApiError;
	status: 500;
};

export type listSkillVersionsResponseSuccess = listSkillVersionsResponse200 & {
	headers: Headers;
};
export type listSkillVersionsResponseError = (
	| listSkillVersionsResponse400
	| listSkillVersionsResponse401
	| listSkillVersionsResponse403
	| listSkillVersionsResponse404
	| listSkillVersionsResponse500
) & {
	headers: Headers;
};

export type listSkillVersionsResponse =
	| listSkillVersionsResponseSuccess
	| listSkillVersionsResponseError;

export const getListSkillVersionsUrl = (
	username: Username,
	name: SkillName,
) => {
	return `/api/skills/@user/${username}/${name}/versions`;
};

export const listSkillVersions = async (
	username: Username,
	name: SkillName,
	options?: RequestInit,
): Promise<listSkillVersionsResponse> => {
	return customFetch<listSkillVersionsResponse>(
		getListSkillVersionsUrl(username, name),
		{
			...options,
			method: "GET",
		},
	);
};

/**
 * Get metadata for a specific skill version
 * @summary Get skill version
 */
export type getSkillVersionResponse200 = {
	data: SkillVersionWithDownload;
	status: 200;
};

export type getSkillVersionResponse400 = {
	data: ValidationError;
	status: 400;
};

export type getSkillVersionResponse401 = {
	data: ApiError;
	status: 401;
};

export type getSkillVersionResponse403 = {
	data: ApiError;
	status: 403;
};

export type getSkillVersionResponse404 = {
	data: ApiError;
	status: 404;
};

export type getSkillVersionResponse500 = {
	data: ApiError;
	status: 500;
};

export type getSkillVersionResponseSuccess = getSkillVersionResponse200 & {
	headers: Headers;
};
export type getSkillVersionResponseError = (
	| getSkillVersionResponse400
	| getSkillVersionResponse401
	| getSkillVersionResponse403
	| getSkillVersionResponse404
	| getSkillVersionResponse500
) & {
	headers: Headers;
};

export type getSkillVersionResponse =
	| getSkillVersionResponseSuccess
	| getSkillVersionResponseError;

export const getGetSkillVersionUrl = (
	username: Username,
	name: SkillName,
	version: Semver,
) => {
	return `/api/skills/@user/${username}/${name}/${version}`;
};

export const getSkillVersion = async (
	username: Username,
	name: SkillName,
	version: Semver,
	options?: RequestInit,
): Promise<getSkillVersionResponse> => {
	return customFetch<getSkillVersionResponse>(
		getGetSkillVersionUrl(username, name, version),
		{
			...options,
			method: "GET",
		},
	);
};

/**
 * Publish a new skill or a new version of an existing skill
 * @summary Publish skill
 */
export type publishSkillResponse200 = {
	data: PublishSkillResponse;
	status: 200;
};

export type publishSkillResponse400 = {
	data: ValidationError;
	status: 400;
};

export type publishSkillResponse401 = {
	data: ApiError;
	status: 401;
};

export type publishSkillResponse403 = {
	data: ApiError;
	status: 403;
};

export type publishSkillResponse404 = {
	data: ApiError;
	status: 404;
};

export type publishSkillResponse500 = {
	data: ApiError;
	status: 500;
};

export type publishSkillResponseSuccess = publishSkillResponse200 & {
	headers: Headers;
};
export type publishSkillResponseError = (
	| publishSkillResponse400
	| publishSkillResponse401
	| publishSkillResponse403
	| publishSkillResponse404
	| publishSkillResponse500
) & {
	headers: Headers;
};

export type publishSkillResponse =
	| publishSkillResponseSuccess
	| publishSkillResponseError;

export const getPublishSkillUrl = () => {
	return "/api/skills/publish";
};

export const publishSkill = async (
	publishSkillInput: PublishSkillInput,
	options?: RequestInit,
): Promise<publishSkillResponse> => {
	return customFetch<publishSkillResponse>(getPublishSkillUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(publishSkillInput),
	});
};

/**
 * Delete a skill and all its versions (owner only)
 * @summary Delete skill
 */
export type deleteSkillResponse200 = {
	data: SuccessResponse & unknown;
	status: 200;
};

export type deleteSkillResponse400 = {
	data: ValidationError;
	status: 400;
};

export type deleteSkillResponse401 = {
	data: ApiError;
	status: 401;
};

export type deleteSkillResponse403 = {
	data: ApiError;
	status: 403;
};

export type deleteSkillResponse404 = {
	data: ApiError;
	status: 404;
};

export type deleteSkillResponse500 = {
	data: ApiError;
	status: 500;
};

export type deleteSkillResponseSuccess = deleteSkillResponse200 & {
	headers: Headers;
};
export type deleteSkillResponseError = (
	| deleteSkillResponse400
	| deleteSkillResponse401
	| deleteSkillResponse403
	| deleteSkillResponse404
	| deleteSkillResponse500
) & {
	headers: Headers;
};

export type deleteSkillResponse =
	| deleteSkillResponseSuccess
	| deleteSkillResponseError;

export const getDeleteSkillUrl = (name: SkillName) => {
	return `/api/skills/${name}`;
};

export const deleteSkill = async (
	name: SkillName,
	options?: RequestInit,
): Promise<deleteSkillResponse> => {
	return customFetch<deleteSkillResponse>(getDeleteSkillUrl(name), {
		...options,
		method: "DELETE",
	});
};

/**
 * Delete a specific version of a skill (owner only). Only allowed within 72 hours of publishing. After that, use deprecate instead.
 * @summary Delete skill version
 */
export type deleteSkillVersionResponse200 = {
	data: SuccessResponse & unknown;
	status: 200;
};

export type deleteSkillVersionResponse400 = {
	data: ValidationError;
	status: 400;
};

export type deleteSkillVersionResponse401 = {
	data: ApiError;
	status: 401;
};

export type deleteSkillVersionResponse403 = {
	data: ApiError;
	status: 403;
};

export type deleteSkillVersionResponse404 = {
	data: ApiError;
	status: 404;
};

export type deleteSkillVersionResponse500 = {
	data: ApiError;
	status: 500;
};

export type deleteSkillVersionResponseSuccess =
	deleteSkillVersionResponse200 & {
		headers: Headers;
	};
export type deleteSkillVersionResponseError = (
	| deleteSkillVersionResponse400
	| deleteSkillVersionResponse401
	| deleteSkillVersionResponse403
	| deleteSkillVersionResponse404
	| deleteSkillVersionResponse500
) & {
	headers: Headers;
};

export type deleteSkillVersionResponse =
	| deleteSkillVersionResponseSuccess
	| deleteSkillVersionResponseError;

export const getDeleteSkillVersionUrl = (name: SkillName, version: Semver) => {
	return `/api/skills/${name}/${version}`;
};

export const deleteSkillVersion = async (
	name: SkillName,
	version: Semver,
	options?: RequestInit,
): Promise<deleteSkillVersionResponse> => {
	return customFetch<deleteSkillVersionResponse>(
		getDeleteSkillVersionUrl(name, version),
		{
			...options,
			method: "DELETE",
		},
	);
};

/**
 * Mark a skill version as deprecated with a message. Deprecated versions are still downloadable but show warnings to users.
 * @summary Deprecate skill version
 */
export type deprecateSkillVersionResponse200 = {
	data: SkillVersion;
	status: 200;
};

export type deprecateSkillVersionResponse400 = {
	data: ValidationError;
	status: 400;
};

export type deprecateSkillVersionResponse401 = {
	data: ApiError;
	status: 401;
};

export type deprecateSkillVersionResponse403 = {
	data: ApiError;
	status: 403;
};

export type deprecateSkillVersionResponse404 = {
	data: ApiError;
	status: 404;
};

export type deprecateSkillVersionResponse500 = {
	data: ApiError;
	status: 500;
};

export type deprecateSkillVersionResponseSuccess =
	deprecateSkillVersionResponse200 & {
		headers: Headers;
	};
export type deprecateSkillVersionResponseError = (
	| deprecateSkillVersionResponse400
	| deprecateSkillVersionResponse401
	| deprecateSkillVersionResponse403
	| deprecateSkillVersionResponse404
	| deprecateSkillVersionResponse500
) & {
	headers: Headers;
};

export type deprecateSkillVersionResponse =
	| deprecateSkillVersionResponseSuccess
	| deprecateSkillVersionResponseError;

export const getDeprecateSkillVersionUrl = (
	name: SkillName,
	version: Semver,
) => {
	return `/api/skills/${name}/${version}/deprecate`;
};

export const deprecateSkillVersion = async (
	name: SkillName,
	version: Semver,
	deprecateVersionInput: DeprecateVersionInput,
	options?: RequestInit,
): Promise<deprecateSkillVersionResponse> => {
	return customFetch<deprecateSkillVersionResponse>(
		getDeprecateSkillVersionUrl(name, version),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(deprecateVersionInput),
		},
	);
};

/**
 * Remove the deprecation status from a skill version.
 * @summary Remove deprecation from skill version
 */
export type undeprecateSkillVersionResponse200 = {
	data: SkillVersion;
	status: 200;
};

export type undeprecateSkillVersionResponse400 = {
	data: ValidationError;
	status: 400;
};

export type undeprecateSkillVersionResponse401 = {
	data: ApiError;
	status: 401;
};

export type undeprecateSkillVersionResponse403 = {
	data: ApiError;
	status: 403;
};

export type undeprecateSkillVersionResponse404 = {
	data: ApiError;
	status: 404;
};

export type undeprecateSkillVersionResponse500 = {
	data: ApiError;
	status: 500;
};

export type undeprecateSkillVersionResponseSuccess =
	undeprecateSkillVersionResponse200 & {
		headers: Headers;
	};
export type undeprecateSkillVersionResponseError = (
	| undeprecateSkillVersionResponse400
	| undeprecateSkillVersionResponse401
	| undeprecateSkillVersionResponse403
	| undeprecateSkillVersionResponse404
	| undeprecateSkillVersionResponse500
) & {
	headers: Headers;
};

export type undeprecateSkillVersionResponse =
	| undeprecateSkillVersionResponseSuccess
	| undeprecateSkillVersionResponseError;

export const getUndeprecateSkillVersionUrl = (
	name: SkillName,
	version: Semver,
) => {
	return `/api/skills/${name}/${version}/deprecate`;
};

export const undeprecateSkillVersion = async (
	name: SkillName,
	version: Semver,
	options?: RequestInit,
): Promise<undeprecateSkillVersionResponse> => {
	return customFetch<undeprecateSkillVersionResponse>(
		getUndeprecateSkillVersionUrl(name, version),
		{
			...options,
			method: "DELETE",
		},
	);
};

/**
 * Change the visibility of a skill. Private packages can be made public, but public packages cannot be made private (this is irreversible, like npm).
 * @summary Change skill visibility
 */
export type changeSkillAccessResponse200 = {
	data: ChangeAccessResponse;
	status: 200;
};

export type changeSkillAccessResponse400 = {
	data: ValidationError;
	status: 400;
};

export type changeSkillAccessResponse401 = {
	data: ApiError;
	status: 401;
};

export type changeSkillAccessResponse403 = {
	data: ApiError;
	status: 403;
};

export type changeSkillAccessResponse404 = {
	data: ApiError;
	status: 404;
};

export type changeSkillAccessResponse500 = {
	data: ApiError;
	status: 500;
};

export type changeSkillAccessResponseSuccess = changeSkillAccessResponse200 & {
	headers: Headers;
};
export type changeSkillAccessResponseError = (
	| changeSkillAccessResponse400
	| changeSkillAccessResponse401
	| changeSkillAccessResponse403
	| changeSkillAccessResponse404
	| changeSkillAccessResponse500
) & {
	headers: Headers;
};

export type changeSkillAccessResponse =
	| changeSkillAccessResponseSuccess
	| changeSkillAccessResponseError;

export const getChangeSkillAccessUrl = (name: SkillName) => {
	return `/api/skills/${name}/access`;
};

export const changeSkillAccess = async (
	name: SkillName,
	changeAccessInput: ChangeAccessInput,
	options?: RequestInit,
): Promise<changeSkillAccessResponse> => {
	return customFetch<changeSkillAccessResponse>(getChangeSkillAccessUrl(name), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(changeAccessInput),
	});
};

/**
 * Submit client-side errors for logging and monitoring. Used by the frontend error capture service.
 * @summary Report client errors
 */
export type reportErrorsResponse200 = {
	data: SuccessResponse;
	status: 200;
};

export type reportErrorsResponse400 = {
	data: ValidationError;
	status: 400;
};

export type reportErrorsResponse401 = {
	data: ApiError;
	status: 401;
};

export type reportErrorsResponse403 = {
	data: ApiError;
	status: 403;
};

export type reportErrorsResponse404 = {
	data: ApiError;
	status: 404;
};

export type reportErrorsResponse500 = {
	data: ApiError;
	status: 500;
};

export type reportErrorsResponseSuccess = reportErrorsResponse200 & {
	headers: Headers;
};
export type reportErrorsResponseError = (
	| reportErrorsResponse400
	| reportErrorsResponse401
	| reportErrorsResponse403
	| reportErrorsResponse404
	| reportErrorsResponse500
) & {
	headers: Headers;
};

export type reportErrorsResponse =
	| reportErrorsResponseSuccess
	| reportErrorsResponseError;

export const getReportErrorsUrl = () => {
	return "/errors/report";
};

export const reportErrors = async (
	errorReportPayload: ErrorReportPayload,
	options?: RequestInit,
): Promise<reportErrorsResponse> => {
	return customFetch<reportErrorsResponse>(getReportErrorsUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(errorReportPayload),
	});
};
